[{"content":"What is Bullet?\n---------------\n\nBullet is a functional PHP micro-framework that helps you easily create REST\nAPIs and web applications that automatically conform to the requirements of the\n[HTTP specification](http:\/\/www.ietf.org\/rfc\/rfc2616.txt). Bullet is resource\nand URI-oriented and comes pre-loaded with powerful HTTP features like\ncontent-negotiation and caching.\n\nRequirements\n------------\n\n * PHP 5.3+ (PHP 5.4 recommended)\n * [Composer](http:\/\/getcomposer.org) for all package management and\n   autoloading (may require command-line access)\n\nRules\n-----\n\n * Apps are **built around HTTP URIs** and defined paths, not forced MVC\n   (but MVC-style [code organization](\/docs\/organization) is still highly recommended and\n   encouraged)\n * Bullet handles **one segment of the path at a time**, and executes the\n   callback for that path segment before proceesing to the next segment \n   (path callbacks are executed from left to right, until the entire path\n   is consumed).\n * If the entire path cannot be consumed, a `404` error will be returned (path\n   was not found).\n * If the path can be fully consumed, and HTTP method handlers are present\n   in the path but none are matched, a `405` \"Method Not Allowed\" response\n   will be returned (if the request is a POST, but you only have a GET handler).\n * If the path can be fully consumed, and format handlers are present in\n   the path but none are matched, a `406` \"Not Acceptable\" response will\n   be returned (if 'xml' is requested, but you only have a 'json' handler).\n\nAdvantages\n----------\n\n * **Super flexible routing**. Because of the way the routing callbacks are\n   nested, Bullet's routing system is one of the most flexible of any other PHP\n   framework or library. You can build any URL you want and respond to any HTTP\n   method on that URL. Routes are not restricted to specific patterns or URL\n   formats, and do not require a controller with specific method names to\n   respond to specific HTTP methods. You can nest routes as many levels deep as\n   you want to expose nested resources like `posts\/42\/comments\/943\/edit` with a\n   level of ease and elegance not found elsewhere.\n\n * **Reduced code duplication (DRY)**. Bullet takes full advantage of its nested\n   closure routing system to reduce a lot of typical code duplication required\n   in most other frameworks. In a typical MVC framework controller, some code\n   has to be duplicated across methods that perform CRUD operations to run ACL\n   checks and load required resources like a Post object to view, edit or delete.\n   With Bullet's nested closure style, this code can be written just once in a\n   path or param callback, and then you can `use` the loaded object in subsequent\n   path, param, or HTTP method handlers. This eliminates the need for \"before\"\n   hooks and filters, because you can just run the checks and load objects you\n   need before you define other nested paths and `use` them when required.\n\nSyntax\n------\n\nBullet is not your typical PHP micro framework. Instead of defining a full\npath pattern or a typical URL route with a callback and parameters mapped\nto a REST method (GET, POST, etc.), Bullet parses only ONE URL segment\nat a time, and only has two methods for working with paths: `path` and\n`param`. As you may have guessed, `path` is for static path names like\n\"blog\" or \"events\" that won't change, and `param` is for variable path\nsegments that need to be captured and used, like \"42\" or \"my-post-title\".\nYou can then respond to paths using nested HTTP method callbacks that\ncontain all the logic for the action you want to perform.\n\nThis type of unique callback nesting eliminates repetitive code for\nloading records, checking authentication, and performing other setup\nwork found in typical MVC frameworks or other microframeworks where each\ncallback or action is in a separate scope or class method.\n\n{% geshi 'php' %}\n$app = new Bullet\\App(array(\n    'template.cfg' => array('path' => __DIR__ . '\/templates')\n));\n\n\/\/ 'blog' subdirectory\n$app->path('blog', function($request) use($app) {\n\n    $blog = somehowGetBlogMapper(); \/\/ Your ORM or other methods here\n\n    \/\/ 'posts' subdirectory in 'blog' ('blog\/posts')\n    $app->path('posts', function() use($app, $blog) {\n\n        \/\/ Load posts once for handling by GET\/POST\/DELETE below\n        $posts = $blog->allPosts(); \/\/ Your ORM or other methods here\n\n        \/\/ Handle GET on this path\n        $app->get(function() use($posts) {\n            \/\/ Display all $posts\n            return $app->template('posts\/index', compact('posts'));\n        });\n\n        \/\/ Handle POST on this path\n        $app->post(function() use($posts) {\n            \/\/ Create new post\n            $post = new Post($request->post());\n            $mapper->save($post);\n            return $this->response($post->toJSON(), 201);\n        });\n\n        \/\/ Handle DELETE on this path\n        $app->delete(function() use($posts) {\n            \/\/ Delete entire posts collection\n            $posts->deleteAll();\n            return 200;\n        });\n\n    });\n});\n\n\/\/ Run the app and echo the response\necho $app->run(\"GET\", \"blog\/posts\");\n{% endgeshi %}\n\n### Capturing Path Parameters\n\nPerhaps the most compelling use of URL routing is to capture path\nsegments and use them as parameters to fetch items from a database, like\n`\/posts\/42` and `\/posts\/42\/edit`. Bullet has a special `param` handler\nfor this that takes two arguments: a `test` callback that validates the\nparameter type for use, and and a `Closure` callback. If the `test`\ncallback returns boolean `false`, the closure is never executed, and the\nnext path segment or param is tested. If it returns boolean `true`, the\ncaptured parameter is passed to the Closure as the second argument.\n\nJust like regular paths, HTTP method handlers can be nested inside param\ncallbacks, as well as other paths, more parameters, etc.\n\n{% geshi 'php' %}\n$app = new Bullet\\App(array(\n    'template.cfg' => array('path' => __DIR__ . '\/templates')\n));\n$app->path('posts', function($request) use($app) {\n    \/\/ Integer path segment, like 'posts\/42'\n    $app->param('int', function($request, $id) use($app) {\n        $app->get(function($request) use($id) {\n            \/\/ View post\n            return 'view_' . $id;\n        });\n        $app->put(function($request) use($id) {\n            \/\/ Update resource\n            $post->data($request->post());\n            $post->save();\n            return 'update_' . $id;\n        });\n        $app->delete(function($request) use($id) {\n            \/\/ Delete resource\n            $post->delete();\n            return 'delete_' . $id;\n        });\n    });\n    \/\/ URL slug (alphanumeric with dashes and underscores)\n    $app->param('slug', function($request, $slug) use($app) {\n        return $slug; \/\/ 'my-post-title'\n    });\n});\n\n\/\/ Results of above code\necho $app->run('GET',   '\/posts\/42'); \/\/ 'view_42'\necho $app->run('PUT',   '\/posts\/42'); \/\/ 'update_42'\necho $app->run('DELETE', '\/posts\/42'); \/\/ 'delete_42'\n\necho $app->run('DELETE', '\/posts\/my-post-title'); \/\/ 'my-post-title'\n{% endgeshi %}\n\nReturning JSON (Useful for PHP JSON APIs)\n-----------------------------------------\n\nBullet has built-in support for returning JSON responses. If you return\nan array from a route handler (callback), Bullet will assume the\nresponse is JSON and automatically `json_encode` the array and return the\nHTTP response with the appropriate `Content-Type: application\/json` header.\n\n{% geshi 'php' %}\n$app->path('\/', function($request) use($app) {\n    $app->get(function($request) use($app) {\n        \/\/ Links to available resources for the API\n        $data = array(\n            '_links' => array(\n                'restaurants' => array(\n                    'title' => 'Restaurants',\n                    'href' => $app->url('restaurants')\n                ),\n                'events' => array(\n                    'title' => 'Events',\n                    'href' => $app->url('events')\n                )\n            )\n        );\n\n        \/\/ Format responders\n        $app->format('json', function($request), use($app, $data) {\n            return $data; \/\/ Auto json_encode on arrays for JSON requests\n        });\n        $app->format('xml', function($request), use($app, $data) {\n            return custom_function_convert_array_to_xml($data);\n        });\n        $app->format('html', function($request), use($app, $data) {\n            return $app->template('index', array('links' => $data));\n        });\n    });\n});\n{% endgeshi %}\n\n\n### HTTP Response Bullet Sends:\n\n    Content-Type:application\/json\n\n    {\"_links\":{\"restaurants\":{\"title\":\"Restaurants\",\"href\":\"http:\\\/\\\/yourdomain.local\\\/restaurants\"},\"events\":{\"title\":\"Events\",\"href\":\"http:\\\/\\\/yourdomain.local\\\/events\"}}}\n\n\n\nNested Requests (HMVC style code re-use)\n----------------------------------------\n\nSince you explicitly `return` values from Bullet routes instead of\nsending output directly, nested\/sub requests are straightforward and easy.\nAll route handlers will return `Bullet\\Response` instances (even if they\nreturn a raw string or other data type, they are wrapped in a response\nobject by the `run` method), and they can be composed to form a single\nHTTP response.\n\n{% geshi 'php' %}\n$app = new Bullet\\App();\n$app->path('foo', function($request) use($app) {\n    return \"foo\";\n});\n$app->path('bar', function($request) use($app) {\n    $foo = $app->run('GET', 'foo'); \/\/ $foo is now a `Bullet\\Response` instance\n    return $foo->content() . \"bar\";\n});\necho $app->run('GET', 'bar'); \/\/ echos 'foobar' with a 200 OK status\n{% endgeshi %}\n\n\nRunning Tests\n-------------\n\nTo run the Bullet test suite, simply run `phpunit` in the root of the\ndirectory where the bullet files are in. Please make sure to add tests\nand run the test suite before submitting pull requests for any contributions.\n\nCredits\n-------\n\nBullet - and specifically path-based callbacks that fully embrace HTTP\nand encourage a more resource-oriented design - is something I have been\nthinking about for a long time, and was finally moved to create it after\nseeing [@joshbuddy](https:\/\/github.com\/joshbuddy) give a presentation on [Renee](http:\/\/reneerb.com\/)\n(Ruby) at [Confoo](http:\/\/confoo.ca) 2012 in Montr\u00e9al.\n\n","format":null}]